RewriteEngine On

# 1. MULTIPLE MÉTHODES pour transmettre le header Authorization
# (serveurs mutualisés 1&1/IONOS ont des configurations variables)

# Méthode A: Syntaxe classique
RewriteCond %{HTTP:Authorization} .
RewriteRule ^ - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

# Méthode B: Avec capture
RewriteCond %{HTTP:Authorization} ^(.*)
RewriteRule .* - [e=HTTP_AUTHORIZATION:%1]

# Méthode C: SetEnvIf (backup)
<IfModule mod_setenvif.c>
    SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
</IfModule>

# Méthode D: Pour CGI/FastCGI
<IfModule mod_headers.c>
    # Tentative de copier le header dans l'environnement
    SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
</IfModule>

# Méthode E: Pour PHP en mode CGI (1&1/IONOS utilise souvent ce mode)
<IfModule mod_rewrite.c>
    # Force le passage du header même en CGI
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
</IfModule>

# Note: La gestion CORS est déléguée aux fichiers PHP (cors.php)
# pour éviter l'erreur "Duplicate Access-Control-Allow-Origin".

# 2. Bloquer l'accès direct aux fichiers sensibles
<FilesMatch "^(\.env|database\.sql|composer\.json|config\.php)$">
    Order allow,deny
    Deny from all
</FilesMatch>

# 3. Optimisations
<IfModule mod_deflate.c>
    AddOutputFilterByType DEFLATE application/json text/plain
</IfModule>
